---
name: typescript-source-gen
description: >-
  TypeScript source code generation for solving problems that cannot be expressed
  in standard TypeScript. Use when type erasure prevents zero-arg generic APIs,
  when payloadType/discriminant literals need runtime presence without repetition,
  when Proxy-based method interception can replace runtime registration, or when
  codegen (TanStack-style) bridges compile-time types to runtime values. Triggers
  on: "source code generation", "codegen", "generate factory", "type erasure",
  "payloadType", "zero argument generic", "Proxy intercept", "withEvent", "runtime
  type name", "DRY generics", "can't pass string", "type only".
---

# TypeScript Source Code Generation

When standard TypeScript cannot express a pattern without duplication or runtime hacks, two solutions exist: **Proxy-based interception** and **code generation**. Often they combine.

## When Standard TypeScript Fails

The core problem: **TypeScript generics are erased at runtime**. You cannot do:

```ts
// IMPOSSIBLE: cannot read "MyEvent" string from type parameter at runtime
factory.withEvent<MyEvent>()  // how does runtime know the string "MyEvent"?
```

This appears in patterns like:
- POCO event types where `payloadType: "Foo"` is a literal but there's no class
- Factory builders needing to register a method name derived from a generic type
- Any API where the caller wants zero-arg `<T>()` but the runtime needs `T["someField"]`

---

## Solution 1: Proxy-Based Method Interception

**When to use:** The information needed at runtime is already embedded in the call site — specifically in the **method name itself**.

### The Pattern

Instead of registering methods from a list, proxy the constructor so any `appendEvent*` call derives the payload type from the property name:

```ts
// In EvDbStreamFactory.createDynamicStreamClass():
const ProxiedStream = new Proxy(DynamicStream, {
  construct(target, args) {
    const instance = new target(...args);
    return new Proxy(instance, {
      get(obj, prop) {
        if (typeof prop === "string" && prop.startsWith("appendEvent")) {
          const payloadType = prop.slice("appendEvent".length);
          return (event: Record<string, unknown>) =>
            obj.appendEventPayload({ ...event, payloadType });
        }
        const value = Reflect.get(obj, prop, obj);
        return typeof value === "function" ? value.bind(obj) : value;
      },
    });
  },
});
```

**Key details:**
- Proxy the **class constructor**, not the instance — so `new ProxiedStream(...)` returns a proxied instance
- Use `Reflect.get(obj, prop, obj)` (not `obj[prop]`) to preserve prototype chain correctly
- `protected` methods are inaccessible from the Proxy's `get` trap — add a `public` bridge method on the inner class:
  ```ts
  public appendEventPayload(payload: Record<string, unknown>): void {
    this.appendEvent(payload as IEvDbEventPayload); // calls the protected method
  }
  ```
- `withEvent<T>()` becomes **truly zero-arg** — purely a TypeScript type accumulator, no runtime effect

**Result:** The TypeScript type system generates `appendEventFundsDeposited(event: Omit<FundsDeposited, "payloadType">)` signatures. The Proxy handles any such call at runtime without any registration list.

---

## Solution 2: TanStack-Style Code Generation

**When to use:** The Proxy approach cannot provide the runtime value (e.g., for message routing by event name, or when method names alone aren't enough). Generate the factory file from the source of truth.

### The Mental Model

Exactly like TanStack Router's `routeTree.gen.ts`:
- The **event type files** are the source of truth (e.g., `FundsEvents/FundsDeposited.ts`)
- A **codegen script** scans them, extracts `payloadType` literals via regex, and writes the factory file
- The generated file has a `// @generated by evdb-codegen` header — developers never edit it
- Developers only write POCO types, then run `npm run generate:stream-factory`

### Extracting Literals via Regex

No full TypeScript compiler API needed — the pattern is consistent and regex is sufficient:

```ts
function extractEventInfo(filePath: string): { typeName: string; payloadType: string } | null {
  const source = fs.readFileSync(filePath, "utf-8");
  // Handles: payloadType: "Foo"  (type alias)
  //      and: payloadType = "Foo"  (class property)
  const payloadTypeMatch = source.match(/payloadType[:\s=]+["']([^"']+)["']/);
  if (!payloadTypeMatch) return null;
  const exportMatch = source.match(/export\s+(?:type|class)\s+(\w+)/);
  if (!exportMatch) return null;
  return { typeName: exportMatch[1], payloadType: payloadTypeMatch[1] };
}
```

### Generated File Shape

```ts
// @generated by evdb-codegen — do not edit manually
import { StreamFactoryBuilder } from "@eventualize/core/factories/StreamFactoryBuilder";
import type { FundsDeposited } from "./FundsEvents/FundsDeposited.js";
// ...

const FundsStreamFactory = new StreamFactoryBuilder("funds-stream")
  .withEvent<FundsDeposited>()   // type-only, zero-arg
  .withEvent<FundsCaptured>()
  .build();                      // Proxy handles runtime dispatch
```

The `payloadType` strings never appear in user-authored code. They live only in:
1. The POCO type definition (`payloadType: "FundsDeposited"`)
2. The generated `eventTypes` array (if needed for message routing)

### Codegen Script Structure

```
packages/core/src/codegen/generateStreamFactory.ts   ← the generator
npm run generate:stream-factory <events-dir> <stream-type>
```

Place in `packages/core/src/codegen/` so it's co-located with the factory it generates for.

---

## Combining Both Solutions

The final architecture used in this project:

| Concern | Solution |
|---|---|
| Type-safe `appendEvent*` method signatures | `withEvent<T>()` zero-arg accumulates `TEvents` union |
| Runtime `appendEvent*` dispatch | Proxy strips prefix → `payloadType` |
| Message routing by event name (optional) | `eventTypes[]` array from codegen or `withEventType(Class)` |
| Generated factory file | Codegen writes `.withEvent<T>().build()` — developer never types strings |

**`withEventType(Class)`** (the class-based path) continues to work unchanged — it derives the name from `Class.name` at runtime. Use it when events have message producers or when a class is preferred.

---

## Decision Tree

```
Need appendEvent* methods on a stream?
├── Events are POCOs (type aliases)?
│   ├── Method name carries all info needed → Proxy solution
│   │   └── withEvent<T>() zero-arg + Proxy in createDynamicStreamClass()
│   └── Also need event names for routing/messages → add Codegen
│       └── npm run generate:stream-factory → .build() with Proxy
└── Events are classes?
    └── withEventType(Class) → Class.name provides runtime string
```

## Standards and Conventions

- Generated files: `// @generated by evdb-codegen — do not edit manually` header
- Codegen lives in `packages/core/src/codegen/` (co-located with what it generates for)
- npm script: `"generate:stream-factory": "tsx packages/core/src/codegen/generateStreamFactory.ts"`
- `withEvent<T>()` is always zero-arg — it is a type accumulator only
- `withEventType(Class)` is always for classes — it pushes to `eventTypes[]` at runtime
- The Proxy intercepts `appendEvent*` and all other property accesses fall through via `Reflect.get`
