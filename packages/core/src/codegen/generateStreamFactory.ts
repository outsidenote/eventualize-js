#!/usr/bin/env node
/**
 * EvDb Stream Factory Code Generator
 *
 * Two modes:
 *
 * MODE 1 — Spec file (preferred):
 *   Reads a *StreamSpec.ts file decorated with @WithEvent<T>() markers and
 *   generates a sibling *StreamFactory.ts file.
 *
 *   Usage:
 *     tsx packages/core/src/codegen/generateStreamFactory.ts <spec-file> <stream-type>
 *
 *   Example:
 *     tsx packages/core/src/codegen/generateStreamFactory.ts \
 *       apps/sample-app/src/eventstore/FundsStream/FundsStreamSpec.ts \
 *       funds-stream
 *
 * MODE 2 — Events directory (legacy):
 *   Scans a *Events/ directory, extracts `payloadType` literals from POCO event types,
 *   and regenerates the sibling *StreamFactory.ts file.
 *
 *   Usage:
 *     tsx packages/core/src/codegen/generateStreamFactory.ts <events-dir> <stream-type>
 *
 *   Example:
 *     tsx packages/core/src/codegen/generateStreamFactory.ts \
 *       apps/sample-app/src/eventstore/FundsStream/FundsEvents \
 *       funds-stream
 *
 * The generated factory exports a builder function (without .build()) so callers
 * can chain additional configuration (e.g. .withView()) before calling .build().
 */

import * as fs from "node:fs";
import * as path from "node:path";

interface EventInfo {
  typeName: string;
  payloadType: string;
}

// ─── Mode 1: Spec-file scanner ────────────────────────────────────────────────

/**
 * Extracts event type names from a *StreamSpec.ts file by scanning for
 * @WithEvent<TypeName>() decorator calls.
 */
function extractFromSpec(specFilePath: string): EventInfo[] {
  const source = fs.readFileSync(specFilePath, "utf-8");
  const matches = [...source.matchAll(/@WithEvent<(\w+)>\s*\(\)/g)];
  return matches.map((m) => ({
    typeName: m[1],
    payloadType: m[1], // convention: type name === payloadType string
  }));
}

/**
 * Generates the factory from a *StreamSpec.ts file.
 * Exported so batch runners (generateAllStreamFactories.ts) can call it directly.
 */
export function generateFromSpec(specFilePath: string): void {
  const absoluteSpecPath = path.resolve(specFilePath);

  if (!fs.existsSync(absoluteSpecPath)) {
    throw new Error(`Spec file not found: ${absoluteSpecPath}`);
  }

  const events = extractFromSpec(absoluteSpecPath);

  if (events.length === 0) {
    throw new Error(
      `No @WithEvent<T>() decorators found in: ${absoluteSpecPath}`,
    );
  }

  const specDir = path.dirname(absoluteSpecPath);
  const specBaseName = path.basename(absoluteSpecPath); // e.g. "FundsStreamSpec.ts"
  const streamName = specBaseName.replace(/Spec\.ts$/, ""); // e.g. "FundsStream"
  const outputPath = path.join(specDir, `${streamName}Factory.ts`);

  // Detect the events subdirectory name (e.g. "FundsEvents")
  const eventsSubDir = streamName.replace(/Stream$/, "") + "Events"; // e.g. "FundsEvents"
  const relativeEventsDir = `./${eventsSubDir}`;

  const imports = events
    .map(
      (e) =>
        `import type { ${e.typeName} } from "${relativeEventsDir}/${e.typeName}.js";`,
    )
    .join("\n");

  const withEventCalls = events
    .map((e) => `    .withEvent<${e.typeName}>("${e.payloadType}")`)
    .join("\n");

  const factoryVarName = streamName + "Factory"; // e.g. "FundsStreamFactory"

  const output = `// @generated by evdb-codegen — do not edit manually
// Source: ${specBaseName}
import { StreamFactoryBuilder } from "@eventualize/core/factories/StreamFactoryBuilder";
${imports}

export const ${factoryVarName} = (streamType: string) =>
  new StreamFactoryBuilder(streamType)
${withEventCalls};

export type ${streamName}Type = ReturnType<typeof ${factoryVarName}>;
`;

  fs.writeFileSync(outputPath, output, "utf-8");
  console.log(`Generated: ${outputPath}`);
  events.forEach((e) =>
    console.log(`  - ${e.typeName} (payloadType: "${e.payloadType}")`),
  );
}

// ─── Mode 2: Events directory scanner (legacy) ────────────────────────────────

/**
 * Extracts the exported type/class name and its `payloadType` literal from a TS source file.
 * Handles both:
 *   export type Foo = ... & { readonly payloadType: "Foo"; ... }
 *   export class Foo implements ... { readonly payloadType = "Foo"; }
 */
function extractEventInfoFromFile(
  filePath: string,
): (EventInfo & { importPath: string }) | null {
  const source = fs.readFileSync(filePath, "utf-8");

  // Match: payloadType: "SomeLiteral"  (type alias)
  // or:    payloadType = "SomeLiteral"  (class property)
  const payloadTypeMatch = source.match(/payloadType[:\s=]+["']([^"']+)["']/);
  if (!payloadTypeMatch) return null;

  const payloadType = payloadTypeMatch[1];

  // Match exported type or class name
  const exportMatch = source.match(/export\s+(?:type|class)\s+(\w+)/);
  if (!exportMatch) return null;

  const typeName = exportMatch[1];

  return { typeName, payloadType, importPath: filePath };
}

function generateFromEventsDir(eventsDir: string, streamType: string): void {
  const absoluteEventsDir = path.resolve(eventsDir);

  if (!fs.existsSync(absoluteEventsDir)) {
    throw new Error(`Events directory not found: ${absoluteEventsDir}`);
  }

  const eventFiles = fs
    .readdirSync(absoluteEventsDir)
    .filter((f) => f.endsWith(".ts") && !f.endsWith(".test.ts"))
    .map((f) => path.join(absoluteEventsDir, f));

  const events: (EventInfo & { importPath: string })[] = [];
  for (const file of eventFiles) {
    const info = extractEventInfoFromFile(file);
    if (info) events.push(info);
  }

  if (events.length === 0) {
    throw new Error(`No event types found in: ${absoluteEventsDir}`);
  }

  // Determine output path: sibling of eventsDir named <ParentStream>Factory.ts
  const parentDir = path.dirname(absoluteEventsDir);
  const eventsDirName = path.basename(absoluteEventsDir); // e.g. "FundsEvents"
  const streamName = eventsDirName.replace(/Events$/, ""); // e.g. "Funds"
  const outputPath = path.join(parentDir, `${streamName}StreamFactory.ts`);

  // Relative import paths from the factory file to each event file
  const relativeEventsDir = `./${eventsDirName}`;

  const imports = events
    .map(
      (e) =>
        `import type { ${e.typeName} } from "${relativeEventsDir}/${e.typeName}.js";`,
    )
    .join("\n");

  // Zero-arg withEvent calls — type inference only, Object.defineProperty handles runtime dispatch
  const withEventCalls = events
    .map((e) => `  .withEvent<${e.typeName}>()`)
    .join("\n");

  const streamVarName = `${streamName}StreamFactory`;

  const output = `// @generated by evdb-codegen — do not edit manually
// Source: ${path.relative(parentDir, absoluteEventsDir)}
import { StreamFactoryBuilder } from "@eventualize/core/factories/StreamFactoryBuilder";
${imports}

const ${streamVarName} = new StreamFactoryBuilder("${streamType}")
${withEventCalls}
  .build();

export default ${streamVarName};

export type ${streamName}StreamType = typeof ${streamVarName}.StreamType;
`;

  fs.writeFileSync(outputPath, output, "utf-8");
  console.log(`Generated: ${outputPath}`);
  events.forEach((e) =>
    console.log(`  - ${e.typeName} (payloadType: "${e.payloadType}")`),
  );
}

// ─── CLI entry point (only runs when executed directly, not when imported) ────

const isMain =
  process.argv[1] &&
  path.resolve(process.argv[1]).replace(/\.[jt]s$/, "") ===
    new URL(import.meta.url).pathname.replace(/\.[jt]s$/, "");

if (isMain) {
  const [input, streamType] = process.argv.slice(2);

  if (!input) {
    console.error(
      "Usage:\n" +
        "  # Spec-file mode (preferred):\n" +
        "  tsx generateStreamFactory.ts <spec-file.ts>\n" +
        "  Example: tsx generateStreamFactory.ts apps/sample-app/src/eventstore/FundsStream/FundsStreamSpec.ts\n\n" +
        "  # Events-directory mode (legacy):\n" +
        "  tsx generateStreamFactory.ts <events-dir> <stream-type>\n" +
        "  Example: tsx generateStreamFactory.ts apps/sample-app/src/eventstore/FundsStream/FundsEvents funds-stream",
    );
    process.exit(1);
  }

  const absoluteInput = path.resolve(input);
  const isSpecFile =
    fs.existsSync(absoluteInput) &&
    fs.statSync(absoluteInput).isFile() &&
    absoluteInput.endsWith("Spec.ts");

  if (isSpecFile) {
    generateFromSpec(input);
  } else {
    if (!streamType) {
      console.error("Events-directory mode requires a <stream-type> argument.");
      process.exit(1);
    }
    generateFromEventsDir(input, streamType);
  }
}
